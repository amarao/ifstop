#!/usr/bin/python

#    (c) Selectel, 2013
#    by George Shuklin
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

'''
    display top of interfaces in system

    Note: this utility designed to be portable:
        * single file to execute
        * python 2.4 (default Centos 5)
        * no non-standart dependencies
'''
import os,sys,time,stat
import curses

class Stats(dict):
    def __init__(self,scan_path):
        dict.__init__(self)
        errors=[
            "collisions",
            "rx_crc_errors", 
            "rx_dropped", 
            "rx_errors", 
            "rx_fifo_errors", 
            "rx_frame_errors", 
            "rx_length_errors",    
            "rx_missed_errors",
            "rx_over_errors",
            "tx_aborted_errors",
            "tx_carrier_errors",
            "tx_dropped",
            "tx_errors",
            "tx_fifo_errors",
            "tx_heartbeat_errors",
            "tx_window_errors"
        ] #all them are displayed as 'errors'
        stat2int=lambda f:int(open(os.path.join(scan_path,'statistics',f)).read().strip())
        self['errors']=sum(map(stat2int, errors))
        self['rx']=stat2int('rx_bytes')
        self['tx']=stat2int('tx_bytes')
        self['rxp']=stat2int('rx_packets')
        self['txp']=stat2int('tx_packets')

    def __sub__(self,second):
        return dict((key,self[key]-second[key]) for key in self.iterkeys())


class IF:
    def __init__(self, path,name):
        self.path=path
        self.name=name
        self.vanished=False
        self.new=True

    def tick(self):
        try:
            new_raw=Stats(os.path.join(self.path,self.name))
            if hasattr(self,'raw'):
                self.stats=new_raw-self.raw
                self.new=False
            self.raw=new_raw
        except IOError:
            print self.name, "disappear"
            self.vanished=True #no stats - no interface

    def bool(self):
        return self.vanished

    def result(self,screen,tick=1):
        screen.addstr(str(self).ljust(10)+'\t')
        if not self.new:
            for field in "errors","tx","tx","txp", "rxp":
                screen.addstr(str(self.stats[field]).ljust(12))
        else:
            screen.addstr("new interface (gathering)")
        if self.vanished:
            screen.addstr("VANISHED")
        screen.addstr('\n')
            
    def __str__(self):
        return self.name

    def cmp_keys(self,key):
        if not self.new:
            return self.stats[key]
        else:
            return -1
        

class Ifaces(list):
    def __init__(self,sys_path='/sys/class/net'):
        list.__init__(self)
        self.sys_path=sys_path
        self.rescan()

    def rescan(self):
#       map(self.remove,filter(bool, self))
       d=[f for f in os.listdir(self.sys_path) if stat.S_ISDIR(os.stat(os.path.join(self.sys_path,f)).st_mode)] 
       new_ifaces=set(map(str,d))-set(map(str,self))
       if new_ifaces:
            map (self.append, map(lambda i: IF(self.sys_path,i), new_ifaces))
       map(IF.tick,self)

    def dump(self,screen,tick=1):
        list.sort(self,key=lambda x: x.cmp_keys('rxp'),reverse=True)
        screen.clear()
        screen.addstr("iface")
        for item in ['errors','TX (bytes)', 'RX (bytes)','TX (packets)', 'RX (packets)']:
            screen.addstr(item.ljust(12))
        screen.addstr('\n')
        for i in self:
            IF.result(i,screen)
        screen.refresh()

def sleepkey(screen):
    '''
        return tuple of key (key or -1 if no key) and actual wait time (in seconds)
    '''
    before=time.time()
    key=screen.getch()
    after=time.time()
    return (key,after-before)

def main(stdscr):
    curses.use_default_colors()
    stdscr.timeout(1000)
    ifaces=Ifaces()
    while 1:
        (key,delay)=sleepkey(stdscr)
        if delay < 0.001:
            delay=0.001
        ifaces.dump(stdscr,tick=delay)
        ifaces.rescan()

if __name__ == "__main__":
        curses.wrapper(main)

